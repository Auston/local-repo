#!/usr/bin/env python3.2

import sys
from argparse import ArgumentParser

from localrepo.package import Package
from localrepo.repo import Repo
from localrepo.aur import Aur
from localrepo.msg import Msg

class LocalRepo:
	''' The main class for the local-repo programm '''

	def __init__(self, path):
		''' The constructor needs the path to the repo database file '''
		Msg.process('Loading repo database:', path)
		self.repo = Repo(path)

	def print_size(self):
		''' Prints the number of packages '''
		Msg.info(str(self.repo.size), 'packages found')

	def list_packages(self):
		''' Print all repo packages '''
		if self.repo.size is 0:
			Msg.info('This repo has no packages')
			return

		for name, pkg in sorted(self.repo.packages.items()):
			Msg.info(pkg.name, pkg.version)

	def package_info(self, name):
		''' Print all available info of apackage '''
		if not self.repo.has_package(name):
			Msg.error('Package does not exist:', name)
			return False

		for k, v in self.repo.package(name).infos.items():
			Msg.info('{0:10} {1}'.format(k, v))

		return True

	def find_packages(self, q):
		''' Search the repo for packages '''
		res = self.repo.find_packages(q)

		if not res:
			Msg.info('No package found')
			return

		for r in res:
			Msg.info(r, self.repo.package(r).version)

	def add_package(self, path, upgrade=False):
		''' Add a package to the repo '''
		Msg.process('Making a new package')

		try:
			pkg = Package.forge(path)

			if upgrade:
				Msg.process('Upgrading package:', pkg.name)
				self.repo.upgrade(pkg)
			else:
				Msg.process('Adding package to the repo:', pkg.name)
				self.repo.add(pkg)

			return True
		except Exception as e:
			Msg.error(str(e))
			return False

	def remove_package(self, name):
		''' Remove a package from the repo '''
		if not self.repo.has_package(name):
			Msg.error('Package does not exist:', name)
			return False

		Msg.process('Removing package:', name)

		try:
			self.repo.remove(name)
			return True
		except Exception as e:
			Msg.error(str(e))
			return False

	def add_package_from_aur(self, name):
		''' Download, make and add a package from the AUR '''
		Msg.process('Retrieving package infos from the AUR')

		try:
			pkg = Aur.package(name)
		except Exception as e:
			Msg.error(str(e))
			return False

		if self.repo.has_package(pkg['name']):
			Msg.error('Package is already in the repo:', pkg['name'])
			return False

		return self.add_package(pkg['uri'])

	def upgrade_aur_packages(self):
		''' Upgrades all packages from the AUR '''
		Msg.info(str(self.repo.size), 'packages found')
		Msg.process('Retrieving package infos from the AUR')

		try:
			pkgs = Aur.packages(self.repo.packages)
		except Exception as e:
			Msg.error(str(e))
			return False

		Msg.info(str(len(pkgs)), 'packages found')
		Msg.process('Checking for updates')
		updates = []

		for name in (pkg for pkg in pkgs if self.repo.has_package(pkg)):
			if pkgs[name]['version'] > self.repo.package(name).version:
				updates.append(pkgs[name])

		if not updates:
			Msg.info('All packages are up to date')
			return True

		for pkg in updates:
			Msg.result('{0} ({1} -> {2})'.format(pkg['name'], self.repo.package(pkg['name']).version,
			                                     pkg['version']))

		if not Msg.yes('Upgrade'):
			Msg.info('Bye')
			return True

		for pkg in updates:
			if not self.add_package(pkg['uri'], True):
				return False

		return True

	def check(self):
		''' Run an integrity check '''
		Msg.info(str(self.repo.size), 'packages found')
		Msg.process('Running integrity check')
		errors = self.repo.check()

		if not errors:
			Msg.info('No errors found')

		for e in errors:
			Msg.error(e)

	def restore_db(self):
		''' Try to restore the database file '''
		Msg.process('Restoring database')

		try:
			self.repo.restore_db()
			return True
		except Exception as e:
			Msg.error(str(e))
			return False

	@staticmethod
	def shutdown(error):
		''' Clean up '''
		Package.clean()
		exit(0) if not error else exit(1)

	@staticmethod
	def abort():
		Msg.error('Execution cancelled by user')
		LocalRepo.shutdown(True)

# GO!
if __name__ == '__main__':

	# Handle KeyboardInterrupt
	excepthook = sys.excepthook

	def lr_excepthook(type, value, traceback):
		if not type is KeyboardInterrupt:
			excepthook(type, value, traceback)
		else:
			LocalRepo.abort()

	sys.excepthook = lr_excepthook

	# Configure ArgumentParser
	p = ArgumentParser(description='This programm helps to manage local repositories. Specify\
	                   the path to the repository database with the last argument and choose at\
	                   least one operation from the options list.', usage='%(prog)s [options] path')
	p.add_argument('path', type=str, metavar='path', help='path to the repo database')
	p.add_argument('-l', '--list', action='store_true', dest='list', default=False,
	               help='list all packages from the repo')
	p.add_argument('-i', '--info', action='store', dest='info', type=str, metavar='name',
	               help='display infos for the specified package')
	p.add_argument('-s', '--search', action='store', dest='search', type=str, metavar='term',
	               help='find packages by term')
	p.add_argument('-a', '--add', action='store', dest='add', type=str, metavar='path',
	               help='add a package to the repo. path can point to a package file, a pkgbuild\
	               tarball or can be the uri of a downloadable pkgbuild tarball, e.g. in the AUR')
	p.add_argument('-u', '--upgrade', action='store', dest='upgrade', type=str, metavar='path',
	               help='upgrade a package by replacing it with a new package. see --add for a\
	               description of the path argument')
	p.add_argument('-r', '--remove', action='store', dest='remove', type=str, metavar='name',
	               help='remove the package specified by name from the repo')
	p.add_argument('-A', '--aur-add', action='store', dest='aur_add', type=str, metavar='name',
	               help='download, build and add a package specified by name from the AUR to the\
	               repo')
	p.add_argument('-U', '--aur-upgrade', action='store_true', dest='aur_upgrade', default=False,
	               help='upgrade all packages in the repo, which are available in the AUR')
	p.add_argument('-c', '--check', action='store_true', dest='check', default=False,
	               help='run an integrity check')
	p.add_argument('-R', '--restore', action='store_true', dest='restore', default=False,
	               help='Restore repo database')

	args = p.parse_args()
	args.size = False
	path = args.path
	del(args.path)

	if not any([var[1] for var in vars(args).items()]):
		args.size = True

	try:
		r = LocalRepo(path)
	except Exception as e:
		Msg.error(str(e))
		exit(1)

	error = False

	if args.size:
		r.print_size()
	elif args.check:
		r.check()
	elif args.restore:
		if not r.restore_db():
			error = True
	elif args.list:
		r.list_packages()
	elif args.info is not None:
		if not r.package_info(args.info):
			error = True
	elif args.search is not None:
		r.find_packages(args.search)
	elif args.add is not None:
		if not r.add_package(args.add):
			error = True
	elif args.upgrade is not None:
		if not r.add_package(args.upgrade, True):
			error =True
	elif args.remove is not None:
		if not r.remove_package(args.remove):
			error = True
	elif args.aur_add is not None:
		if not r.add_package_from_aur(args.aur_add):
			error = True
	elif args.aur_upgrade:
		if not r.upgrade_aur_packages():
			error = True

	LocalRepo.shutdown(True) if error else LocalRepo.shutdown(False)
